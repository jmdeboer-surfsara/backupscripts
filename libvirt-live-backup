#!/bin/bash

# Backs up running Libvirt virtual machines by creating snapshots.

# Based on http://wiki.libvirt.org/page/Live-disk-backup-with-active-blockcommit
# Disclaimer: this script could destroy your data! Don't use without testing first!
# Features:
#  * Can back up one VM or all running VMs (with --all)
#  * If a VM has multiple block devices, all will be backed up
#  * The backups will be sparse files, to save space

# Changelog
# 2017-07-26 - Initial version - Onno
# 2017-07-27 - Code improvements - Onno
# 2017-07-27 - Copies will be sparse files - Onno
# 2017-07-27 - VM XML will be backed up too - Onno

usage() {
  echo "Backs up a running VM by creating a temporary snapshot."
  echo "Usage:"
  echo "    $0 [VM] [targethost:]/targetdir"
  echo "    $0 --all [targethost:]/targetdir"
}

if [ -z "$1" ] ; then
  echo "Please specify a VM to back up, or specify --all."
  virsh list --all
  exit 1
fi

if [ -z "$2" ] ; then
  usage
  echo "Please specify a location to back up to."
  exit 1
fi

# Name suffix for the overlay files
SUFFIX='-libvirt-live-backup-overlay'

# Define some functions

get_block_devs() {
  # List the block devices (vda etc.) for a domain.
  virsh domblklist "$VM" --details | awk '$2 == "disk" {print $3}'
}

get_snapshot_backing_files() {
  # virsh does not seem to have a command to get the backing files of a snapshot.
  # virsh domblklist only lists the overlay files when a snapshot has been made;
  # not the actual files we want to back up.
  # So we need to extract the backing files from the VM XML output.
  VM="$1"
  virsh dumpxml "$VM" \
  | sed -n "/<backingStore type='file'/,/<\/backingStore>/ { /source file/p }" \
  | sed -e "s/.*<source file='\(.*\)'\/>.*/\1/g"
}

copy_xml() {
  VM="$1"
  xmlfile=$(mktemp)
  echo "Copying the XML definition of '$VM'..."
  virsh dumpxml "$VM" > "$xmlfile"
  rsync --archive "$xmlfile" "$TARGETDIR/$VM.xml"
  rm -f "$xmlfile"
  echo "Done."
}

create_vm_snapshot() {
  VM="$1"
  if virsh domblklist "$VM" --details | grep 'disk' | grep -v '\.qcow2' ; then
    echo "ERROR: this VM contains a disk that is not qcow2 format. This has not been tested."
    exit 1
  fi
  diskspecs=$(virsh domblklist "$VM" --details \
              | awk '$2 == "disk" {print "--diskspec " $3 ",file=" $4}' \
              | sed -e "s/\.qcow2$/$SUFFIX.qcow2/" \
              | tr '\n' ' ')
  # First try with --quiesce to get more consistent snapshot; if that fails, try without; if that failes, quit.
  virsh snapshot-create-as --domain "$VM" \
                           --name "$VM-snapshot" \
                           $diskspecs \
                           --disk-only --atomic --quiesce \
  || virsh snapshot-create-as --domain "$VM" \
                           --name "$VM-snapshot" \
                           $diskspecs \
                           --disk-only --atomic \
  || exit 1
}

copy_disks() {
  # Make a copy of the disks snapshots.
  VM="$1"
  echo "Copying snapshot disks to '$TARGETDIR' ..."
  # disks may have different names than the VM! extract names from domblklist!
  for file in $(get_snapshot_backing_files "$VM") ; do
    echo "  $file"
    # Why the two rsyncs?
    # It's a trick to make the replica also a sparse file, and still have efficient (inplace) transfers. 
    # See https://serverfault.com/questions/66338/how-do-you-synchronise-huge-sparse-files-vm-disk-images-between-machines
    rsync --archive --existing --inplace       "$file" "$TARGETDIR"
    rsync --archive --ignore-existing --sparse "$file" "$TARGETDIR"
  done
}

remove_vm_snapshot() {
  VM="$1"
  success=''
  # For each block device, commit the changes in the overlay into the backing store.
  for blockdev in $(get_block_devs "$VM") ; do
    virsh blockcommit "$VM" $blockdev --active --verbose --wait --pivot \
    || exit 1
  done
  # Now delete the snapshot.
  virsh snapshot-delete --domain "$VM" --metadata "$VM-snapshot" \
  || exit 1
  # Print a list of the current status.
  echo "Cleaning up committed overlay files..."
  files_in_use=$(virsh dumpxml $VM | awk -F  "'" '/<source file=.*/ {print $2}')
  for overlayfile in $(virsh domblklist "$VM" --details \
                       | awk '$2 == "disk" {print $4}' \
                       | sed -e "s/\.qcow2$/$SUFFIX.qcow2/")
  do
    # But first: test if the file is in use by the VM!
    if fgrep "$overlayfile" <<<"$files_in_use" ; then
      echo "ERROR: file '$overlayfile' is still referred to in the description of $VM. Please check 'virsh dumpxml $VM'"
      echo "Not deleting '$overlayfile'."
    else
      echo "  $overlayfile"
      rm -f "$overlayfile"
    fi
  done
  virsh domblklist "$VM" --details
}

# End of functions; start working here


# Did we get a VM name, or --all?
case "$1" in
  --all ) 
    VMLIST=$(virsh list | awk '/running/ {print $2}') ;;
  * )
    VMLIST="$1" ;;
esac

TARGETDIR="$2"
mkdir -p "$TARGETDIR"

for VM in $VMLIST ; do
  copy_xml "$VM"
  create_vm_snapshot "$VM"
  copy_disks "$VM"
  remove_vm_snapshot "$VM"
done
